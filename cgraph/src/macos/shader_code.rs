// Auto-generated from 'metal/' directory
pub const SHADER_CODE: &str = "// File: metal/main.metal\n\n#include <metal_stdlib>\nusing namespace metal;\n\nstruct VertexIn {\n    float2 position [[attribute(0)]];\n    float4 color [[attribute(1)]];\n    float zIndex [[attribute(2)]];\n    float2 uv [[attribute(3)]];\n};\n\nstruct VertexOut {\n    float4 position [[position]];\n    float4 color;\n    float2 uv;\n};\n\nstruct Uniforms {\n    float2 rect_position;\n    float2 rect_size;\n    float corner_radius;\n    float4x4 model_matrix;\n    float4x4 projection_matrix;\n    bool use_texture;\n};\n\nstruct ShadowUniforms {\n    float offset_x;\n    float offset_y;\n    float radius;\n    float4 color;\n    bool enabled;\n};\n\nvertex VertexOut vertex_main(VertexIn in [[stage_in]], constant Uniforms& uniforms [[buffer(1)]]) {\n    VertexOut out;\n    float depth = (0 + in.zIndex) / 50;\n    out.position = uniforms.projection_matrix * uniforms.model_matrix * float4(in.position, depth, 1.0);\n    out.color = in.color;\n    out.uv = in.uv;\n    return out;\n}\n\nfloat rounded_rect_sdf(float2 p, float2 size, float corner_radius) {\n    float2 d = abs(p) - size + corner_radius;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - corner_radius;\n}\n\nfloat calculate_shadow_expanded(float2 uv, float2 original_rect_size, float corner_radius, float blur_radius) {\n    float expansion = blur_radius;\n    \n    float2 expanded_size = original_rect_size + float2(expansion * 2.0, expansion * 2.0);\n    \n    float2 expanded_pos = (uv - 0.5) * expanded_size;\n    \n    float2 half_original_size = original_rect_size * 0.5;\n    float dist = rounded_rect_sdf(expanded_pos, half_original_size, corner_radius);\n    \n    float shadow_alpha = 1.0 - smoothstep(-blur_radius, blur_radius, dist);\n    \n    return clamp(shadow_alpha, 0.0, 1.0);\n}\n\nfragment float4 fragment_main(VertexOut in [[stage_in]], \n                             constant Uniforms& uniforms [[buffer(0)]],\n                             texture2d<float> tex [[texture(0)]],\n                             sampler texSampler [[sampler(0)]],\n                             constant ShadowUniforms& shadowUniforms [[buffer(2)]]) {\n    \n    if (shadowUniforms.enabled) {\n        float shadow_alpha = calculate_shadow_expanded(\n            in.uv, \n            uniforms.rect_size, \n            uniforms.corner_radius, \n            shadowUniforms.radius\n        );\n        \n        if (shadow_alpha <= 0.01) {\n            discard_fragment();\n        }\n        \n        float4 shadow_color = shadowUniforms.color;\n        shadow_color.a *= shadow_alpha;\n        return shadow_color;\n    }\n    \n    float4 final_color;\n    \n    if (uniforms.use_texture) {\n        float4 tex_color = tex.sample(texSampler, in.uv);\n        final_color = tex_color;\n    } else {\n        final_color = in.color;\n    }\n    \n    if (uniforms.corner_radius > 0.0) {\n        float2 local_pos = (in.uv - 0.5) * uniforms.rect_size;\n        float2 half_size = uniforms.rect_size * 0.5;\n        \n        float dist = rounded_rect_sdf(local_pos, half_size, uniforms.corner_radius);\n        \n        float alpha = 1.0 - smoothstep(-1.0, 1.0, dist);\n        if (alpha <= 0.0) {\n            discard_fragment();\n        }\n        final_color.a *= alpha;\n    }\n    \n    return final_color;\n}\n\n";
